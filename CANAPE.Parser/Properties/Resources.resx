<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BaseParser_CMPFailure" xml:space="preserve">
    <value>Fixed byte value does not match required value read '{0}' required '{1}'</value>
  </data>
  <data name="BaseParser_NoValidSequenceChoice" xml:space="preserve">
    <value>No valid sequence choice in type {0}. Specify a default type if required</value>
  </data>
  <data name="BaseParser_RSCStreamCannotSeek" xml:space="preserve">
    <value>The DataReader stream must be seekable to perform magic style sequence matching</value>
  </data>
  <data name="BaseParser_ValidateFailed" xml:space="preserve">
    <value>Validation failed with expression '{0}'</value>
  </data>
  <data name="BitFieldMemberEntry_BitsDescription" xml:space="preserve">
    <value>The number of bits if using a bit field</value>
  </data>
  <data name="BitField_InvalidSize" xml:space="preserve">
    <value>Bit field must be between 0 and 64 bits in size</value>
  </data>
  <data name="BooleanMemberEntry_FalseValueDescription" xml:space="preserve">
    <value>The value to use for False</value>
  </data>
  <data name="BooleanMemberEntry_InvalidValue" xml:space="preserve">
    <value>Cannot represent value {0} in a {1}</value>
  </data>
  <data name="BooleanMemberEntry_TrueValueDescription" xml:space="preserve">
    <value>The value to use for True</value>
  </data>
  <data name="CalculatorMemberEntry_EntryMustBeStringOrPrimitive" xml:space="preserve">
    <value>Entry must be a string or a primitive value</value>
  </data>
  <data name="CalculatorMemberEntry_OnlyCalculatedDescription" xml:space="preserve">
    <value>If true the expressions are used to read and write the member. The base type is just used as its representation.</value>
  </data>
  <data name="CalculatorMemberEntry_ReadExpressionDescription" xml:space="preserve">
    <value>Expression used to calculate a value on read</value>
  </data>
  <data name="CalculatorMemberEntry_WriteExpressionDescription" xml:space="preserve">
    <value>Expression used to calculate a value on write</value>
  </data>
  <data name="CharMemberEntry_StringEncodingDescription" xml:space="preserve">
    <value>The encoding to use for the string</value>
  </data>
  <data name="ContainerMemberEntry_BaseTypeDescription" xml:space="preserve">
    <value>The base member type</value>
  </data>
  <data name="EnumMemberEntry_EnumTypeDescription" xml:space="preserve">
    <value>The enumeration type for this entry</value>
  </data>
  <data name="EnumParserType_IsFlagsDescription" xml:space="preserve">
    <value>Indicates if this enumeration is flags or values</value>
  </data>
  <data name="ExpressionResolver_AtRequires2Arguments" xml:space="preserve">
    <value>at() function requires target and index arguments</value>
  </data>
  <data name="ExpressionResolver_AtTargetNeedsToBeIndexable" xml:space="preserve">
    <value>at() function target needs to be indexable (e.g. string or array)</value>
  </data>
  <data name="ExpressionResolver_CannotFindProperty" xml:space="preserve">
    <value>Cannot resolve property {0}</value>
  </data>
  <data name="ExpressionResolver_CannotFuncFunction" xml:space="preserve">
    <value>Cannot resolve function {0}</value>
  </data>
  <data name="FixedBytesMemberEntry_BytesDescription" xml:space="preserve">
    <value>The byte data to read and write from the stream</value>
  </data>
  <data name="FixedBytesMemberEntry_ValidateDescription" xml:space="preserve">
    <value>If true the byte data read from the stream will be validated</value>
  </data>
  <data name="FixedLengthGenericArrayMemberEntry_LengthDescription" xml:space="preserve">
    <value>Length of the fixed array in elements</value>
  </data>
  <data name="FixedLengthPrimitiveArrayMemberEntry_IsByteLengthDescription" xml:space="preserve">
    <value>Indicates whether the Length field is a number of elements or number of bytes</value>
  </data>
  <data name="FixedLengthPrimitiveArrayMemberEntry_LengthDescription" xml:space="preserve">
    <value>Length of the fixed array in elements</value>
  </data>
  <data name="FixedLengthStringMemberEntry_Description" xml:space="preserve">
    <value>A string which is fixed in length</value>
  </data>
  <data name="FixedLengthStringMemberEntry_IsByteLengthDescription" xml:space="preserve">
    <value>Indicates whether the Length field is a number of elements or number of bytes</value>
  </data>
  <data name="FixedLengthStringMemberEntry_LengthDescription" xml:space="preserve">
    <value>The length of the fixed string in characters units</value>
  </data>
  <data name="FixedLengthStringMemberEntry_PaddingDescription" xml:space="preserve">
    <value>A character to use to pad the string to the correct length if it is too short</value>
  </data>
  <data name="FixedLengthStringMemberEntry_StringLengthInvalid" xml:space="preserve">
    <value>String must be greater or equal to 0 characters</value>
  </data>
  <data name="FloatPrimitiveMemberEntry_InvalidType" xml:space="preserve">
    <value>Type must be a float or double</value>
  </data>
  <data name="GenericStreamParser_ReadException" xml:space="preserve">
    <value>Received exception '{0}' while reading type {1}</value>
  </data>
  <data name="GenericStreamParser_WriteException" xml:space="preserve">
    <value>Received exception '{0}' while writing type {1}</value>
  </data>
  <data name="Generic_LengthDescription" xml:space="preserve">
    <value>The length of the array or string. Can be a complex expression.</value>
  </data>
  <data name="Generic_LengthExpressionDescription" xml:space="preserve">
    <value>An expression to calculate the length instead of using the Length property</value>
  </data>
  <data name="Generic_LengthReadExpressionDescription" xml:space="preserve">
    <value>Specifies an expression which is used to calculate the length when reading the value</value>
  </data>
  <data name="Generic_LengthWriteExpressionDescription" xml:space="preserve">
    <value>Specifies an expression which is used to calculate the length when writing the value</value>
  </data>
  <data name="Generic_TrailingLength" xml:space="preserve">
    <value>An expression which specifies how many trailing bytes are present for this member</value>
  </data>
  <data name="Int7V_InvalidCompareObject" xml:space="preserve">
    <value>Object passed to CompareTo not a Int7V</value>
  </data>
  <data name="IntB_InvalidCompareObject" xml:space="preserve">
    <value>Object passed to CompareTO not an {0}</value>
  </data>
  <data name="IntegerMemberEntry_InvalidType" xml:space="preserve">
    <value>Type must be a primitive type</value>
  </data>
  <data name="IntegerPrimitiveMemberEntry_FormatDescription" xml:space="preserve">
    <value>Specify the display format of the member</value>
  </data>
  <data name="IntegerPrimitiveMemberEntry_InvalidType" xml:space="preserve">
    <value>Type must be an integer type</value>
  </data>
  <data name="MemberEntryReference_CouldNotFindMember" xml:space="preserve">
    <value>Cannot find member {0} in reference chain</value>
  </data>
  <data name="MemberEntryReference_InvalidChain" xml:space="preserve">
    <value>Reference chain is invalid</value>
  </data>
  <data name="MemberEntryReference_InvalidChainMustEndWithTypes" xml:space="preserve">
    <value>Chains must end with built-in types</value>
  </data>
  <data name="MemberEntryReference_InvalidChainMustStartWithSequences" xml:space="preserve">
    <value>Chains with multiple items must start with sequences</value>
  </data>
  <data name="MemberEntry_DescriptionDescription" xml:space="preserve">
    <value>Specify a textual description for this member</value>
  </data>
  <data name="MemberEntry_DisplayClassDescription" xml:space="preserve">
    <value>Specify a guid which determines how the node should be edited and displayed</value>
  </data>
  <data name="MemberEntry_HiddenDescription" xml:space="preserve">
    <value>If set the member is not output in the final structure</value>
  </data>
  <data name="MemberEntry_InvalidFieldReference" xml:space="preserve">
    <value>Invalid field reference</value>
  </data>
  <data name="MemberEntry_InvalidName" xml:space="preserve">
    <value>Name '{0}' is not a valid identifier</value>
  </data>
  <data name="MemberEntry_InvalidReference" xml:space="preserve">
    <value>{0} does not exist as a reference</value>
  </data>
  <data name="MemberEntry_NameAlreadyExists" xml:space="preserve">
    <value>Name '{0}' already exists in the sequence</value>
  </data>
  <data name="MemberEntry_NameDescription" xml:space="preserve">
    <value>Name of the member entry</value>
  </data>
  <data name="MemberEntry_OptionalExpressionDescription" xml:space="preserve">
    <value>An expression which is used to determine if reading or writing this member is optional</value>
  </data>
  <data name="MemberEntry_ReadOnlyDescription" xml:space="preserve">
    <value>If set the member is read only in the final structure</value>
  </data>
  <data name="MemberEntry_TypeNameDescription" xml:space="preserve">
    <value>Name of the type</value>
  </data>
  <data name="MemberEntry_UuidDescription" xml:space="preserve">
    <value>Unique ID of the type</value>
  </data>
  <data name="MemberEntry_ValidateExpressionDescription" xml:space="preserve">
    <value>An expression used to validate the value during parsing</value>
  </data>
  <data name="NumericPrimitiveMemberEntry_CustomFormatDescription" xml:space="preserve">
    <value>Specifies a custom format string for the data (overrides anything else)</value>
  </data>
  <data name="NumericPrimitiveMemberEntry_EndianDescription" xml:space="preserve">
    <value>The endian of the type for parsing (not applicable for bytes)</value>
  </data>
  <data name="ParserType_DescriptionDescription" xml:space="preserve">
    <value>Specify a textual description for this type</value>
  </data>
  <data name="ParserType_DisplayClassDescription" xml:space="preserve">
    <value>Specify a guid which determines how the node should be edited and displayed</value>
  </data>
  <data name="ParserType_UuidDescription" xml:space="preserve">
    <value>Unique ID of the type</value>
  </data>
  <data name="ParserUtils_InvalidPrimitiveType" xml:space="preserve">
    <value>Invalid primitive type</value>
  </data>
  <data name="ReadToEndPrimitiveArrayMemberEntry_TrailingLengthDescription" xml:space="preserve">
    <value>Specifies the number of bytes to not read from the end (note this is _not_ primitive values)</value>
  </data>
  <data name="ReadToEndStringMemberEntry_ToStringFormat" xml:space="preserve">
    <value>{0} String (Read To End)</value>
  </data>
  <data name="ReadToEndStringMemberEntry_ToStringTrailingFormat" xml:space="preserve">
    <value>{0} String (Read To End - {1} characters)</value>
  </data>
  <data name="ReadToEndStringMemberEntry_TrailingLengthDescription" xml:space="preserve">
    <value>This specifies the number of trailing characters to not read from the end</value>
  </data>
  <data name="ReferenceLengthGenericArrayMemberEntry_AdjustmentDescription" xml:space="preserve">
    <value>Specify an adjust value for the length which is added at deserialization and subtracted and serialization</value>
  </data>
  <data name="ReferenceLengthGenericArrayMemberEntry_IsByteLengthDescription" xml:space="preserve">
    <value>Indicates whether the Length field is a number of elements or number of bytes</value>
  </data>
  <data name="ReferenceLengthGenericArrayMemberEntry_ReferenceDescription" xml:space="preserve">
    <value>Define the member reference to get the length from</value>
  </data>
  <data name="ReferenceLengthPrimitiveArrayMemberEntry_AdjustmentDescription" xml:space="preserve">
    <value>Specify an adjust value for the length which is added at deserialization and subtracted and serialization</value>
  </data>
  <data name="ReferenceLengthPrimitiveArrayMemberEntry_IsByteLengthDescription" xml:space="preserve">
    <value>Indicates whether the Length field is a number of elements or number of bytes</value>
  </data>
  <data name="ReferenceLengthPrimitiveArrayMemberEntry_ReferenceDescription" xml:space="preserve">
    <value>Define the member reference to get the length from</value>
  </data>
  <data name="ReferenceLengthStringMemberEntry_AdjustmentDescription" xml:space="preserve">
    <value>Specify an adjust value for the length which is added at deserialization and subtracted and serialization</value>
  </data>
  <data name="ReferenceLengthStringMemberEntry_IsByteLengthDescription" xml:space="preserve">
    <value>Indicates whether the Length field is a number of elements or number of bytes</value>
  </data>
  <data name="ReferenceLengthStringMemberEntry_ReferenceDescription" xml:space="preserve">
    <value>Define the member reference to get the length from</value>
  </data>
  <data name="SequenceChoiceMemberEntry_ChoicesDescription" xml:space="preserve">
    <value>The list of sequence choices to check for</value>
  </data>
  <data name="SequenceChoiceMemberEntry_DefaultType" xml:space="preserve">
    <value>The default sequence type to apply if no other match is made</value>
  </data>
  <data name="SequenceChoiceMemberEntry_MagicParserDescription" xml:space="preserve">
    <value>If true ignores the choice expressions, relies on validation rules in the sequences to determine what to structure is parsed</value>
  </data>
  <data name="SequenceChoiceMemberEntry_ReferenceDescription" xml:space="preserve">
    <value>Reference to auto-populate the 'value' parameter in an expression</value>
  </data>
  <data name="SequenceChoiceMemberEntry_SequenceTypeMustBeASequence" xml:space="preserve">
    <value>To add a choice the type must be a sequence</value>
  </data>
  <data name="SequenceChoice_BooleanExpressionDescription" xml:space="preserve">
    <value>An expression which resolves to a boolean value to determine when to apply this sequence choice</value>
  </data>
  <data name="SequenceChoice_SequenceTypeDescription" xml:space="preserve">
    <value>The type of sequence for this entry</value>
  </data>
  <data name="SequenceParserType_DefaultEndian" xml:space="preserve">
    <value>The endian of the integer type for parsing</value>
  </data>
  <data name="SequenceParserType_MemberAlreadyParented" xml:space="preserve">
    <value>{0} is already a member of another type</value>
  </data>
  <data name="SequenceParserType_NameExists" xml:space="preserve">
    <value>{0} already exists as a member</value>
  </data>
  <data name="SequenceParserType_NotOurMember" xml:space="preserve">
    <value>Provided member is not part of this sequence type</value>
  </data>
  <data name="SequenceParserType_PreserializeExpressionDescription" xml:space="preserve">
    <value>An expression to run prior to data serialization</value>
  </data>
  <data name="SequenceParserType_PrivateDescription" xml:space="preserve">
    <value>If true then this sequence is considered only for internal use</value>
  </data>
  <data name="SizedMemberEntry_ReadExpressionDescription" xml:space="preserve">
    <value>An expression which represents the size of the value to parse</value>
  </data>
  <data name="SizedMemberEntry_ReadToEndDescription" xml:space="preserve">
    <value>If true then the sized entry will read to the end of the stream</value>
  </data>
  <data name="StreamParserType_FormatStringDescription" xml:space="preserve">
    <value>Specify a format string, uses a syntax similar to perl replacement, e.g. "Format $var" will lookup the value 'var' and replace</value>
  </data>
  <data name="StringMemberEntry_StringEncodingDescription" xml:space="preserve">
    <value>The encoding to use for the string</value>
  </data>
  <data name="TerminatedGenericArrayMemberEntry_RequiredDescription" xml:space="preserve">
    <value>Indicates whether the termination condition is required or not. If not then can also read to end of stream.</value>
  </data>
  <data name="TerminatedGenericArrayMemberEntry_TermConditionDescription" xml:space="preserve">
    <value>An expression which specifies the term condition. Use 'value' for the current read element and 'i' for the current index.</value>
  </data>
  <data name="TerminatedGenericArrayMemberEntry_TermExpressionDescription" xml:space="preserve">
    <value>An expression which can be used to terminate the array. The current read value is represented as 'value'</value>
  </data>
  <data name="TerminatedStringMemberEntry_RequiredDescription" xml:space="preserve">
    <value>Set to true to require the terminating character or string, otherwise</value>
  </data>
  <data name="TerminatedStringMemberEntry_TermCharDescription" xml:space="preserve">
    <value>A character to indicate the end of string</value>
  </data>
  <data name="TerminatedStringMemberEntry_TermStringDescription" xml:space="preserve">
    <value>A string to indicate the end of string, can use basic C style escapes such as \n, \t and \0</value>
  </data>
</root>